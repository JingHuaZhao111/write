# 数组

## 二分查找

> 条件：数组为有序数组，无重复元素，如果有重复元素，找到返回的下标可能不唯一

```c++
//习惯
class Soulution{
    public:
    	int search(vector<int>& nums, int target) {
            int left = 0;
            int right = nums.size()-1;
            while (left <= right) {
                int middle = left +((right - left) / 2);
                if (nums[middle] > target) {
                    right = middle -1;
                }else if (nums[middle] < target) {
                    left = middle +1;
                }else {
                    return middle;
                }
            }
            return -1;                 
        }
};
```

```c++
//给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

//由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

//注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 
class Solution {
public:
    int mySqrt(int x) {
        int left=0;
        int right=x;
        int ans=0;
        while(left<=right)
        {
            long long middle=left +((right-left)/2);
            if(middle*middle<x){
                left=middle+1;
            }
            else if (middle*middle > x){
                right = middle-1;
            }
            else
            {
                ans = middle;
                break;
            }
                ans = middle;
        }
        if (ans*ans>x)
        {
            return (ans-1);
        }
        else
            return ans;
}
};
```

## 移除元素

> 条件：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

```c++
//双指针法
class Solution {
    public:
    	int removeElement(vector<int>& nums, int val){
            int slow = 0;
            for (int fast = 0; fast < nums.size(); fast++){
                if(val != nums[fast]){
                    nums[slow] = nums[fast];
                    slow++;
                }
            }
            return slow;
        }
};
```

## 有序数组的平方

> 条件：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

**思路：数组其实是有序的， 只不过负数平方之后可能成为最大数了。**

**那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。**

**此时可以考虑双指针法了，i指向起始位置，j指向终止位置。**

**定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。**

```c++
class Solution {
    public:
    	vector<int> sortedSquares(vector<int>& A){
            int k=A.size()-1;
            vector<int> result(A.size(),0);
            for(int i=0, j=A.size()-1;i<=j;){
                if(A[i] *A[i]<A[j]*A[j])
                {
                    result[k]=A[j]*A[j];
                    k--;
                    j--;
                }
                else{
                    result[k]=A[i]*A[i];
                    k--;
                    i++;
                }
            }
            return result;
                
        }
};
```

## 长度最小的子数组

> 条件：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组,并返回其长度。如果不存在符合条件的子数组，返回 0。

**思路：滑动窗口：窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。**

**窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。**

**窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。**

```c++
class Solution{
    public:
    	int minSubArrayLen(int s, vector<int>& nums){
            int result =INT32_MAX;
            int sum =0;//滑动窗口数值的和
            int start=0;//滑动窗口起始位置
            int subLength =0;//滑动窗口的长度
            for(int end=0;end<nums.size();end++)//end滑动窗口截止位置
            {
                sum+=nums[end];
                while(sum>=s)
                {
                    subLength=(end-start+1);
                    result=result<=subLength?result:subLength;
                    sum=sum-nums[start];
                    start++;
                }
            }
            // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
            return result==INT32_MAX ?0:result;
        }
};
```

## 螺旋矩阵

> 条件：给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

如果要写出正确的二分法一定要坚持**循环不变量原则**。

坚持左闭右开

![螺旋矩阵](https://img-blog.csdnimg.cn/2020121623550681.png)

```c++
class Solution{
    public:
      	vector<vector<int>> generateMatrix(int n){
            vector<vector<int>> res(n,vector<int>(n,0));
            int startx=0,starty=0;//定义每循环一个圈的起始位置
            int loop =n/2;//每个圈循环几次，n为3则循环一圈
            int mid =n/2;//矩阵中间位置
            int count=1;//给矩阵每一个空格赋值
            int offset=1;//每一圈循环需要控制每一条边遍历的长度
            int i,j;
            while(loop--){
                i=startx;
                j=starty;
                
                for(j=starty;j<starty+n-offset;j++){
                    res[startx][j]= count++;
                }
                for(i=startx;i<startx+n-offset;i++){
                    res[i][j]=count++;
                }
                for(;j>starty;j--){
                    res[i][j]=count++;
                }
                for(;i>startx;i--){
                    res[i][j]=count++;
                }
                starty++;
                startx++;
                offset=offset+2;
            }
            if(n%2){
                res[mid][mid]=count;
            }
            return res;
        }
};
```

# 链表

链表定义

```c++
struct ListNode {
  	int val;
    ListNode *next;
    ListNode(int x) :val(x),next(null){}
};
```

## 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

思路：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *dummyhead= new ListNode(0);
        dummyhead->next=head;
        ListNode *current=dummyhead;
        while(current->next!=nullptr){
            if(current->next->val==val){
                ListNode * temp=current->next;
                current->next=temp->next;
                delete temp;
            }
            else{//一定是要else，两个连着都为val的删除操作才能执行
                current=current->next;
            }
        }
        head=dummyhead->next;
        delete dummyhead;
        return head;
    }
};
```

##  设计链表

> 条件：设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next >是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 >0-index 的。
>
> 在链表类中实现这些功能：
>
> get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```c++
class MyLinkedList {

public:
    struct ListNode{
        int val;
        ListNode * next;
        ListNode(int val):val(val),next(nullptr){}
    };
    MyLinkedList() {
		dummyhead=new ListNode(0);
        size=0;
    }
    
    int get(int index) {
        ListNode *p=dummyhead;
   		if(index<0||index>=size)
            return -1;
		while(index--){
            if(p==nullptr)
                return -1;
            p=p->next;
        }
        return p->next->val;
    }
    
    void addAtHead(int val) {
		ListNode *newNode=new ListNode(val);
        newNode->next=dummyhead->next;
        dummyhead->next=newNode;
        size++;
    }
    
    void addAtTail(int val) {
		ListNode *newNode=new ListNode(val);
        ListNode *p=dummyhead;
        while(p->next!=nullptr){
            p=p->next;
        }
        p->next=newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        ListNode *newNode=new ListNode(val);
        ListNode *p=dummyhead;
        if(index>size||index<0){
            return;
        }
        while(index--){
            p=p->next;
        }
        newNode->next=p->next;
        p->next=newNode;
        size++;
    }
    
    void deleteAtIndex(int index) {
		if(index>=size||index<0)
            return;
        ListNode *p=dummyhead;
        while(index--){
            p=p->next;
        }
        ListNode *del=p->next;
        p->next=del->next;
        delete del;
        size--;
    }
private:
    int size;
    ListNode *dummyhead;//一定写结构体后面不然无法定义
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

## 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**思路:首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。**

**然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。**

**为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。**

**接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。**

**最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。**

<u>**双指针**:</u>

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
  		ListNode *temp;
        ListNode *cur=head;
        ListNode * pre=NULL;
        while(cur){
       		temp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
};
```

## 两两交换链表中的节点

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode *p=dummyHead;
        ListNode *rtemp;
        while(p->next!=nullptr&&p->next->next!=nullptr){//一定要都判断,可能最后剩下一个也可能正好全部交换完
            rtemp=p->next->next->next;
            p->next->next->next=p->next;
            p->next=p->next->next;
            p->next->next->next=rtemp;
            p=p->next->next;
        }
        return dummyHead->next;
    }
};
```

## 删除链表的倒数第N个节点

>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
>
>进阶：你能尝试使用一趟扫描实现吗？

**思路：fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），ast和slow同时移动，直到fast指向末尾，删除slow指向的下一个节点。**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummyhead=new ListNode(0);
        dummyhead->next=head;
        ListNode *fast=dummyhead;
        ListNode *slow=dummyhead;
        n=n+1;
        while(fast!=NULL&&n--){
            fast=fast->next;
        }
        while(fast!=NULL){
            fast=fast->next;
            slow=slow->next;
        }
        slow->next=slow->next->next;
        return dummyhead->next;
    }
};
```

## 链表相交

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
>
> 题目数据 保证 整个链式结构中不存在环。
>
> 注意，函数返回结果后，链表必须 保持其原始结构 。

![image-20220126153200765](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220126153200765.png)

![image-20220126153210958](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220126153210958.png)

![image-20220126153221415](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220126153221415.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *curA=headA;
        ListNode *curB=headB;
        int LenA=0,LenB=0;
        while(curA!=NULL){
            LenA++;
            curA=curA->next;
        }
        while(curB!=NULL){
            LenB++;
            curB=curB->next;
        }
        curA=headA;//重新赋值
        curB=headB;
        if(LenA<LenB){
            swap(LenA,LenB);//交换值
            swap(curA,curB);
        }
        int gap=LenA-LenB;
        while(gap--){
            curA=curA->next;
        }
        while(curA!=NULL){
            if(curA==curB){
                return curA;
            }
            curA=curA->next;
            curB=curB->next;
        }
        return NULL;
    }
};
```

## 环形链表二

>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
>不允许修改 链表。

思路：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。**

**假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点节点数为y。 从相遇节点 再到环形入口节点节点数为 z。** 

![image-20220126204257685](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220126204257685.png)

**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

![142.环形链表II（求入口）](https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast=head;
        ListNode *slow=head;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                ListNode *newfast=fast;
                ListNode *newslow=head;
                while(newfast!=newslow){
                    newfast=newfast->next;
                    newslow=newslow->next;
                }
                return newfast;
            }
        }
        return NULL;
    }
};
```

# 哈希表※

> 哈希表是根据关键码的值而直接进行访问的数据结构。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |
| ------------------ | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | $O(\log n)$ | $O(\log n)$ |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | $O(\log n)$ | $O(\log n)$ |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | $O(1)$      | $O(1)$      |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |
| ------------------ | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | $O(\log n)$ | $O(\log n)$ |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | $O(\log n)$ | $O(\log n)$ |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | $O(1)$      | $O(1)$      |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

![image-20220127154648799](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220127154648799.png)

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

## 有效的字母异位词

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```

## 两个数组的交集

> 给定两个数组，编写一个函数来计算它们的交集。

思路：std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。

### 补充语法：

```c++
for(int num : nums2)
```

等同于：

```c++
int num;
for(int i=0;i<nums2.length;i++)
{
num=nums2[i];
}
```

#### unordered_set成员方法

| 成员方法    | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| `find(key)` | 查找值为key的元素，如果找到，则返回一个指向该元素的正向迭代器；如果没找到，则返回一个与end()方法相同的迭代器 |
| `end()`     | 返回指向容器中最后一个元素之后位置的迭代器                   |

## 快乐数

> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。
>
> 如果 n 是快乐数就返回 True ；不是，则返回 False 。

思路：题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

```c++
class Solution {
public:
    // 取数值各个位上的单数之和
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }
            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (set.find(sum) != set.end()) {
                return false;
            } else {
                set.insert(sum);
            }
            n = sum;
        }
    }
};
```

## 两数之和

>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            auto iter = map.find(target - nums[i]);
            if(iter != map.end()) {
                return {iter->second, i};
            }
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

## 四数相加II

>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
>
>0 <= i, j, k, l < n
>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

思路：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> map;
        for(int i=0;i<nums1.size();i++){
            for(int j=0;j<nums1.size();j++){
                map[nums1[i]+nums2[j]]++;
            }
        }
        int count=0;//统计a+b+c+d=0出现的次数
        for(int i=0;i<nums1.size();i++){
            for(int j=0;j<nums1.size();j++){
                if(map.find(0-(nums3[i]+nums4[j]))!=map.end()){
                    count=count+map[0-(nums3[i]+nums4[j])];
                }
            }
        }
        return count;
    }
};
```

## 赎金信

>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
>
>如果可以，返回 true ；否则返回 false 。
>
>magazine 中的每个字符只能在 ransomNote 中使用一次。

```c++
//比哈希快很多
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int array[26]={0};
        for(int i=0;i<magazine.size();i++){
            array[magazine[i]-'a']++;
        }
        for(int i=0;i<ransomNote.size();i++){
            array[ransomNote[i]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(array[i]<0)
                return false;
        }
        return true;
    }
};
```

## 三数之和

>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
>注意：答案中不可以包含重复的三元组。

思路：**其实这道题目使用哈希法并不十分合适**，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。

双指针法，**这道题目使用双指针法 要比哈希法高效一些**

![15.三数之和](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

## 四数之和

>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
>0 <= a, b, c, d < n
>a、b、c 和 d 互不相同
>nums[a] + nums[b] + nums[c] + nums[d] == target
>你可以按 任意顺序 返回答案 。

思路：四数之和，和[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)是一个思路，都是使用双指针法, 基本解法就是在[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)的基础上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断`nums[k] > target` 就返回了，三数之和 可以通过 `nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。（大家亲自写代码就能感受出来）

[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是$O(n^2)$，四数之和的时间复杂度是$O(n^3)$ 。

# 字符串

## 反转字符串

>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
>
>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
            swap(s[i],s[j]);
        }
    }
};
```

## 替换空格

> 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"
>
> ![替换空格](https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif)

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int size1=s.size();
        int number=0;
        for(int i=0;i<size1;i++){
            if(s[i]==' '){
                number++;
            }
        }
        int size2=size1+number*2;
        s.resize(size2);
        for(int i=size1,j=size2;j>i;i--,j--){
            if(s[i]==' '){
                s[j]='0';
                s[j-1]='2';
                s[j-2]='%';
                j=j-2;
            }
            else{
                s[j]=s[i];
            }
        }
        return s;
    }
};
```

## 翻转字符串里的单词（难）

>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
>
>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
>
>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
>
>说明：
>
>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
>翻转后单词间应当仅用一个空格分隔。
>翻转后的字符串中不应包含额外的空格。


思路：将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。

```c++
class Solution {
public:
    void remove(string &s){
        int slow=0,fast=0;
        while(s.size()>0&&fast<s.size() && s[fast]== ' '){
            fast++;
        }//去掉字符串前面的空格
        for(;fast<s.size();fast++){
            if(fast>1&&s[fast-1]==' '&&s[fast]==' '){
                continue;
            }else{
                s[slow]=s[fast];
                slow++;
            }
        }
        if(slow-1>0&&s[slow-1]==' '){
            s.resize(slow-1);
        }else{
            s.resize(slow);
        }
    }
    string reverseWords(string s) {
        remove(s);
        for(int i=0,j=s.size()-1;i<j;i++,j--){
            swap(s[i],s[j]);
        }
        for(int i=0;i<s.size();i++){
            int j=i;
            while(j<s.size()&&s[j]!=' ')
            j++;
            for(int a=i,b=j-1;a<b;a++,b--){
                swap(s[a],s[b]);   
            }
            i=j;
        }
        return s;
    }
};
```

```c++
// 版本一
class Solution {
public:
    // 反转字符串s中左闭又闭的区间[start, end]
    void reverse(string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    // 移除冗余空格：使用双指针（快慢指针法）O(n)的算法
    void removeExtraSpaces(string& s) {
        int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针
        // 去掉字符串前面的空格
        while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == ' ') {
            fastIndex++;
        }
        for (; fastIndex < s.size(); fastIndex++) {
            // 去掉字符串中间部分的冗余空格
            if (fastIndex - 1 > 0
                    && s[fastIndex - 1] == s[fastIndex]
                    && s[fastIndex] == ' ') {
                continue;
            } else {
                s[slowIndex++] = s[fastIndex];
            }
        }
        if (slowIndex - 1 > 0 && s[slowIndex - 1] == ' ') { // 去掉字符串末尾的空格
            s.resize(slowIndex - 1);
        } else {
            s.resize(slowIndex); // 重新设置字符串大小
        }
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); // 去掉冗余空格
        reverse(s, 0, s.size() - 1); // 将字符串全部反转
        int start = 0; // 反转的单词在字符串里起始位置
        int end = 0; // 反转的单词在字符串里终止位置
        bool entry = false; // 标记枚举字符串的过程中是否已经进入了单词区间
        for (int i = 0; i < s.size(); i++) { // 开始反转单词
            if (!entry) {
                start = i; // 确定单词起始位置
                entry = true; // 进入单词区间
            }
            // 单词后面有空格的情况，空格就是分词符
            if (entry && s[i] == ' ' && s[i - 1] != ' ') {
                end = i - 1; // 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
            // 最后一个结尾单词之后没有空格的情况
            if (entry && (i == (s.size() - 1)) && s[i] != ' ' ) {
                end = i;// 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
        }
        return s;
    }
    
    // 当然这里的主函数reverseWords写的有一些冗余的，可以精简一些，精简之后的主函数为：
    /* 主函数简单写法
    string reverseWords(string s) {
        removeExtraSpaces(s);
        reverse(s, 0, s.size() - 1);
        for(int i = 0; i < s.size(); i++) {
            int j = i;
            // 查找单词间的空格，翻转单词
            while(j < s.size() && s[j] != ' ') j++;
            reverse(s, i, j - 1);
            i = j;
        }
        return s;
    }
    */
};
```

## 左旋转字符串

>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

![image-20220128001109451](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220128001109451.png)

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(),s.begin()+n);
        reverse(s.begin()+n,s.end());
        reverse(s.begin(),s.end());
        return s;
    }
};
```

注：reverse反转字符串是前闭后开

## 实现 strStr()

>实现 strStr() 函数。
>
>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
>说明：
>
>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

# 栈与队列

## 用栈实现队列

![image-20220207234456117](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220207234456117.png)

```c++
class MyQueue {
public:
    stack<int> In;
    stack<int> Out;
    MyQueue() {

    }
    
    void push(int x) {
        In.push(x);
    }
    
    int pop() {
        if(Out.empty()){
            while(!In.empty()){
                Out.push(In.top());
                In.pop();
            }
        }
        int result=Out.top();
        Out.pop();
        return result;
    }
    
    int peek() {
        int res=this->pop();
        Out.push(res);
        return res;
    }
    
    bool empty() {
        if(In.empty()&&Out.empty()){
            return true;
        }
        return false;
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## 用队列实现栈

![image-20220208000006973](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220208000006973.png)

```c++
class MyStack {
public:
    queue<int> queue1;
    queue<int> queue2;
    MyStack() {

    }
    
    void push(int x) {
        queue1.push(x);
    }
    
    int pop() {
        int size=queue1.size()-1;
        while(size){
            queue2.push(queue1.front());
            queue1.pop();
            size--;
        }
        int res=queue1.front();
        queue1.pop();
        queue1=queue2;
        while(!queue2.empty()){
            queue2.pop();
        }
        return res;
    }
    
    int top() {
        int res=this->pop();
        queue1.push(res);
        return res;
    }
    
    bool empty() {
        if(queue1.empty()){
            return true;
        }
        return false;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。**

```c++
int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }
```

## 有效的括号

>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
>有效字符串需满足：
>
>左括号必须用相同类型的右括号闭合。
>左括号必须以正确的顺序闭合。

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.size()%2==1){
            return false;
        }
        stack<int> stack1;
        for(int i=0;i<s.size();i++){
            if(s[i]=='('){
                stack1.push(')');   
            }
            else if(s[i]=='['){
                stack1.push(']');   
            }
            else if(s[i]=='{'){
                stack1.push('}');   
            }
            else{
                if(stack1.empty())
                return false;
                int res=stack1.top();
                stack1.pop();
                if(res!=int(s[i])){
                    return false;
                }
            }
        }
        return stack1.empty();
    }
};
```

```c++
class Solution {
public:
    string removeDuplicates(string s) { 
        string ans="";
        for(int i=0;i<s.size();i++){
            if(ans.empty()||ans.back()!=s[i]){
                ans.push_back(s[i]);
            }
            else{
                ans.pop_back();
            }
        }
        return ans;
    }
};
```

#直接利用string不用栈

## 逆波兰表达式求值

> 根据 逆波兰表示法，求表达式的值。
>
> 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 注意 两个整数之间的除法只保留整数部分。
>
> 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

#注意当遇到操作符的时候出栈的两个数先出栈的是右操作数，后出栈的是左操作数

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for(int i=0;i<tokens.size();i++){
            if(tokens[i]=="+"){
                int num1=s.top();
                s.pop();
                int num2=s.top();
                s.pop();
                s.push(num2+num1);
            }
            else if(tokens[i]=="-"){
                int num1=s.top();
                s.pop();
                int num2=s.top();
                s.pop();
                s.push(num2-num1);
            }
            else if(tokens[i]=="*"){
                int num1=s.top();
                s.pop();
                int num2=s.top();
                s.pop();
                s.push(num2*num1);
            }
            else if(tokens[i]=="/"){
                int num1=s.top();
                s.pop();
                int num2=s.top();
                s.pop();
                s.push(num2/num1);
            }
            else s.push(stoi(tokens[i]));
        }
        return s.top();
    }
};
```

#stoi字符串转换数字

```c++
int j=0;
int x=0;
if(tokens[i][0]=='-')
{
    j++;
    while(tokens[i][j]!='\0'){ 
        x=x*10+int(tokens[i][j]-'0');
        j++;
    } 
    x=-x; 

}
else{
    while(tokens[i][j]!='\0'){
        x=x*10+int(tokens[i][j]-'0');
        j++;
    } 
} 
biaodashi.push(x);
```

## 滑动窗口最大值（难）

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
>
> 返回 滑动窗口中的最大值 。

> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值

> ---------------               -----
>
> [1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7

## 前k个高频元素



# 二叉树

## 概念

### 满二叉树

只有度为0和度为2的节点，度为0的都在同一层，深度为k，有2^(k-1)个节点

### 完全二叉树

除了最底层节点可能没填满，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置

![image-20220208231357692](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220208231357692.png)

### 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

### 平衡二叉树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

### 遍历二叉树

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。

   前序遍历，中序遍历，后序遍历

2. 广度优先遍历：一层一层的去遍历。

   层次遍历

### 定义二叉树

```c++
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
```

## 二叉树遍历代码

### 递归

```c++
class Solution{
    public:
    //前序遍历
    	void traversal1(TreeNode *cur,vector<int> &vec){
            if(cur==NULL)return;
            vec.push_back(cur->val);
            traversal1(cur->left,vec);
            traversal1(cur->right,vec);
        }
    //中序遍历
    	void traversal2(TreeNode *cur,vector<int> &vec){
            if(cur==NULL)return;
            traversal2(cur->left,vec);
            vec.push_back(cur->val);
            traversal2(cur->right,vec);
        }
    //后序遍历
    	void traversal3(TreeNode *cur,vector<int> &vec){
            if(cur==NULL)return;            
            traversal3(cur->left,vec);
            traversal3(cur->right,vec);
            vec.push_back(cur->val);
        }
}
```

### 迭代



### 层序

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

![102二叉树的层序遍历](https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode *> que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            vector<int> vec;
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode *temp=que.front();
                vec.push_back(temp->val);
                if(temp->left)
                que.push(temp->left);
                if(temp->right)
                que.push(temp->right);
                que.pop();
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

**自底向上的层序遍历**

```c++
reverse(result.begin(),result.end());
```

### 右视图

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode *> que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode *temp=que.front();
                if(i==size-1){
                    result.push_back(que.front()->val);
                }
                if(temp->left)
                que.push(temp->left);
                if(temp->right)
                que.push(temp->right);
                que.pop();
            }
        }
        return result;
    }
};
```

### 求各层平均值

> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> result;
        queue<TreeNode *>que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            int size=que.size();
            double number=0;
            for(int i=0;i<size;i++){
                TreeNode *temp=que.front();
                number=number+temp->val;
                if(temp->left)
                que.push(temp->left);
                if(temp->right)
                que.push(temp->right);
                que.pop();
            }
            result.push_back(number/size);
        }
        return result;
    }
};
```

### N叉树的层序遍历

> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        queue<Node*> que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            int size=que.size();
            vector<int> vec;
            for(int i=0;i<size;i++){
                Node * temp=que.front();
                vec.push_back(temp->val);
                for(int j=0;j<temp->children.size();j++){
                    if(temp->children[j]){
                        que.push(temp->children[j]);
                    }
                }
                que.pop();
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

#注意孩子结点是个vector

### 在每个树行中找到最大值

> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        queue<TreeNode *> que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            int size=que.size();
            long long number=INT_MIN;
            for(int i=0;i<size;i++){
                TreeNode *temp=que.front();
                if(temp->left)
                que.push(temp->left);
                if(temp->right)
                que.push(temp->right);
                number=number<temp->val?temp->val:number;
                que.pop();
            }
            result.push_back(number);
        }
        return result;
    }
};
```

#最小值INT_MIN

### 填充每个节点的下一个右侧节点指针

> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```c++
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> ```
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。
>

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/
class Solution {
public:
    Node* connect(Node* root) {
        queue <Node*> que;
        if (root){
            que.push(root);
        }
         while(!que.empty()){
             int size=que.size();
             Node* nodepre;
             Node* node;
             for(int i=0;i<size;i++){
                 if(i==0){
                     nodepre =que.front();
                     que.pop();
                     node=nodepre;
                 }else{
                     node =que.front();
                     que.pop();
                     nodepre->next=node;
                     nodepre=nodepre->next;
                 }
                 if(node->left)que.push(node->left);
                 if(node->right)que.push(node->right);
             }
             nodepre->next=NULL;
         }
         return root;          
        }
};
```

### 二叉树的最大深度

>给定一个二叉树，找出其最大深度。
>
>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
>**说明:** 叶子节点是指没有子节点的节点。

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
    if(root==nullptr)  
    return 0; 
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 二叉树的最小深度

>给定一个二叉树，找出其最小深度。
>
>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
>**说明：**叶子节点是指没有子节点的节点。
>
>**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth=0;
        queue<TreeNode*> que;
        if(root){
            que.push(root);
        }
        while(!que.empty()){
            depth++;
            int size=que.size();
            for (int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
                if(node->left==nullptr&&node->right==nullptr)return depth;
            }
        }
        return depth;
    }
};
```

### 反转二叉树

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> ![image-20220223173932155](C:\Users\zjh\AppData\Roaming\Typora\typora-user-images\image-20220223173932155.png)

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return nullptr;
            TreeNode* rightTree = root->right;
            root->right = invertTree(root->left);
            root->left = invertTree(rightTree);
            return root;
    }
};//递归
```

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！**

那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

用栈递归

### 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
bool deal(TreeNode* left,TreeNode* right)
{
    if(left==nullptr&&right==nullptr)
    return true;
    if(left==nullptr&&right!=nullptr)
    return false;
    if(left!=nullptr&&right==nullptr)
    return false;
    if(left->val!=right->val)
    return false;
    return deal(left->left,right->right)&&deal(left->right,right->left);
}
    bool isSymmetric(TreeNode* root) {
       return deal(root->left,root->right);
    }
};
```

#### 相同的树

>给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr&&q==nullptr)
        return true;
        if(p==nullptr&&q!=nullptr)
        return false;
        if(p!=nullptr&&q==nullptr)
        return false;
        if(p->val!=q->val)
        return false;
        return (isSameTree(p->left,q->left)&&isSameTree(p->right,q->right));
    }
};
```

#### 另一棵树的子树

>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
>
>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr&&q==nullptr)
        return true;
        if(p==nullptr&&q!=nullptr)
        return false;
        if(p!=nullptr&&q==nullptr)
        return false;
        if(p->val!=q->val)
        return false;
        return (isSameTree(p->left,q->left)&&isSameTree(p->right,q->right));
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root==nullptr&&subRoot==nullptr)
        return true;
        if(root==nullptr&&subRoot!=nullptr)
        return false;
        return (isSameTree(root,subRoot)||isSubtree(root->left,subRoot)||isSubtree(root->right,subRoot));
    }
};
```

**用上题的相同的树，要么是根节点左子树的子树要么是根节点右子树的子树，要么是根节点的相同的树**

### 完全二叉树的节点个数

>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
>
>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

思路：确定递归函数的参数和返回值：参数就是传入树的根节点，返回就是返回以该节点为根节点二叉树的节点数量，返回值为int类型

确定终止条件：如果为空结点就返回0，表示节点数为0

确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一就是目前节点为根节点的节点数量

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int f(TreeNode * root){
        if(root==nullptr)
        return 0;
        int leftnumber=f(root->left);
        int rightnumber=f(root->right);
        int number=leftnumber+rightnumber+1;
        return number;
    }
    int countNodes(TreeNode* root) {
        return f(root);
    }
};
```

### 树未完





## 回溯算法

